{
  "version": 3,
  "file": "app.bundle.js",
  "mappings": "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",
  "sources": [
    "webpack://demo/./node_modules/@riotjs/hot-reload/index.js",
    "webpack://demo/./node_modules/@riotjs/observable/dist/observable.js",
    "webpack://demo/./src/components/todo/todo.riot",
    "webpack://demo/./node_modules/bianco.query/index.next.js",
    "webpack://demo/./node_modules/bianco.dom-to-array/index.next.js",
    "webpack://demo/./node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js",
    "webpack://demo/./node_modules/mini-css-extract-plugin/dist/hmr/normalize-url.js",
    "webpack://demo/./src/style.css?e320",
    "webpack://demo/./node_modules/riot/riot.esm.js",
    "webpack://demo/./node_modules/riotcontrol/riotcontrol.js",
    "webpack://demo/./src/components/ sync [a-zA-Z0-9-]+\\.riot",
    "webpack://demo/./src/register-global-components.js",
    "webpack://demo/./src/index.js",
    "webpack://demo/./src/libs/todostore.js"
  ],
  "sourcesContent": [
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('riot'), require('bianco.query')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'riot', 'bianco.query'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.riotHotReload = {}, global.riot, global.$));\n}(this, (function (exports, riot, $) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n\n  const { cssManager } = riot.__;\n  const { DOM_COMPONENT_INSTANCE_PROPERTY } = riot.__.globals;\n\n  function reload(componentAPI) {\n    const {name} = componentAPI;\n\n    if (!name) {\n      console.warn('Anonymous components can not be reloaded'); // eslint-disable-line\n      return []\n    }\n\n    return $__default['default'](`${name}, [is=${name}]`).map(el => {\n      const oldTag = el[DOM_COMPONENT_INSTANCE_PROPERTY];\n\n      // early return in case there is no riot instance found\n      if (!oldTag) return\n\n      // remove the tag template from the DOM\n      oldTag.unmount(true);\n      // delete the old css from the css manager\n      cssManager.remove(name);\n\n      // create the new tag\n      const newTag = riot.component(componentAPI)(el, oldTag.props);\n      newTag.update(oldTag.state);\n\n      return newTag\n    })\n  }\n\n  exports.default = reload;\n  exports.reload = reload;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n",
    ";(function(window, undefined) {const ALL_CALLBACKS = '*'\nconst define = Object.defineProperties\nconst entries = Object.entries\n\nconst on = (callbacks, el) => (event, fn) => {\n  if (callbacks.has(event)) {\n    callbacks.get(event).add(fn)\n  } else {\n    callbacks.set(event, new Set().add(fn))\n  }\n\n  return el\n}\n\nconst deleteCallback = (callbacks, el, event,  fn) => {\n  if (fn) {\n    const fns = callbacks.get(event)\n\n    if (fns) {\n      fns.delete(fn)\n      if (fns.size === 0) callbacks.delete(event)\n    }\n  } else callbacks.delete(event)\n}\n\nconst off = (callbacks, el) => (event, fn) => {\n  if (event === ALL_CALLBACKS && !fn) {\n    callbacks.clear()\n  } else {\n    deleteCallback(callbacks, el, event, fn)\n  }\n\n  return el\n}\n\nconst one = (callbacks, el) => (event, fn) => {\n  function on(...args) {\n    el.off(event, on)\n    fn.apply(el, args)\n  }\n  return el.on(event, on)\n}\n\nconst trigger = (callbacks, el) => (event, ...args) => {\n  const fns = callbacks.get(event)\n\n  if (fns) fns.forEach(fn => fn.apply(el, args))\n\n  if (callbacks.get(ALL_CALLBACKS) && event !== ALL_CALLBACKS) {\n    el.trigger(ALL_CALLBACKS, event, ...args)\n  }\n\n  return el\n}\n\nconst observable = function(el) { // eslint-disable-line\n  const callbacks = new Map()\n  const methods = {on, off, one, trigger}\n\n  el = el || {}\n\n  define(el,\n    entries(methods).reduce((acc, [key, method]) => {\n      acc[key] = {\n        value: method(callbacks, el),\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n\n      return acc\n    }, {})\n  )\n\n  return el\n}\n  /* istanbul ignore next */\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = observable\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return observable })\n  else\n    window.observable = observable\n\n})(typeof window != 'undefined' ? window : undefined);",
    "<todo>\n  <h3>RiotControl ToDo Demo</h3>\n\t<span>A Simplistic Central Event Controller / Dispatcher For RiotJS, Inspired By Flux</span>\n  <hr />\n\n  <h3>{ props.title }</h3>\n  <ul>\n    <li each={ item in state.items }>\n      <label class={ item.done && 'completed' }>\n        <input\n          type=\"checkbox\"\n          checked={ item.done }\n          onclick={ () => toggle(item) }> { item.title }\n      </label>\n    </li>\n  </ul>\n\n  <form onsubmit={ add }>\n    <input name=\"input\" onkeyup={ edit }>\n    <button disabled={ !state.text }>Add #{ state.items.length + 1 }</button>\n  </form>\n  <button disabled={ !state.items.length } onclick={ remove } class=\"danger\">Remove</button>\n\n  <script>\n    import TodoStore from '../../libs/todostore'\n    import riox from 'riox'\n\n    export default {\n      state: {\n        disabled: true,\n        items: [],\n        text: \"\"\n      },\n      onBeforeMount(props, state) {\n        // Create store instance\n        const todoStore = new TodoStore()\n        // Register the store in central dispatch.\n        RiotControl.addStore(todoStore)\n        // Register a listener for store change events.\n        RiotControl.on('todos_changed', (items) => {\n          this.update({\n            items: items\n          })\n        })\n      },\n      onMounted() {\n        // Trigger init event when component is mounted to page.\n        // Any store could respond to this.\n        RiotControl.trigger('todo_init')\n      },\n      edit(e) {\n        this.update({\n          text: e.target.value\n        })\n      },\n      add(e) {\n        if (this.state.text) {\n          e.preventDefault()\n\n          // Trigger event to all stores registered in central dispatch.\n          // This allows loosely coupled stores/components to react to same events.\n          e.target.input.value = ''\n          RiotControl.trigger('todo_add', { title: this.state.text })\n        }\n      },\n      toggle(e) {\n        e.done = !e.done\n        this.update()\n      },\n      remove(e) {\n        RiotControl.trigger('todo_remove')\n      }\n    }\n  </script>\n</todo>\n",
    "import domToArray from 'bianco.dom-to-array'\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        scope      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\nexport default function $(selector, scope) {\n  return domToArray(typeof selector === 'string' ?\n    (scope || document).querySelectorAll(selector) :\n    selector\n  )\n}\n",
    "/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nexport default function domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (\n      /^\\[object (HTMLCollection|NodeList|Object)\\]$/\n        .test(Object.prototype.toString.call(els))\n        && typeof els.length === 'number'\n    )\n      return Array.from(els)\n    else\n      // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els]\n  }\n  // this object could be looped out of the box\n  return els\n}",
    "\"use strict\";\n\n/* eslint-env browser */\n\n/*\n  eslint-disable\n  no-console,\n  func-names\n*/\n\n/** @typedef {any} TODO */\nvar normalizeUrl = require(\"./normalize-url\");\n\nvar srcByModuleId = Object.create(null);\nvar noDocument = typeof document === \"undefined\";\nvar forEach = Array.prototype.forEach;\n/**\n * @param {function} fn\n * @param {number} time\n * @returns {(function(): void)|*}\n */\n\nfunction debounce(fn, time) {\n  var timeout = 0;\n  return function () {\n    // @ts-ignore\n    var self = this; // eslint-disable-next-line prefer-rest-params\n\n    var args = arguments;\n\n    var functionCall = function functionCall() {\n      return fn.apply(self, args);\n    };\n\n    clearTimeout(timeout); // @ts-ignore\n\n    timeout = setTimeout(functionCall, time);\n  };\n}\n\nfunction noop() {}\n/**\n * @param {TODO} moduleId\n * @returns {TODO}\n */\n\n\nfunction getCurrentScriptUrl(moduleId) {\n  var src = srcByModuleId[moduleId];\n\n  if (!src) {\n    if (document.currentScript) {\n      src =\n      /** @type {HTMLScriptElement} */\n      document.currentScript.src;\n    } else {\n      var scripts = document.getElementsByTagName(\"script\");\n      var lastScriptTag = scripts[scripts.length - 1];\n\n      if (lastScriptTag) {\n        src = lastScriptTag.src;\n      }\n    }\n\n    srcByModuleId[moduleId] = src;\n  }\n  /**\n   * @param {string} fileMap\n   * @returns {null | string[]}\n   */\n\n\n  return function (fileMap) {\n    if (!src) {\n      return null;\n    }\n\n    var splitResult = src.split(/([^\\\\/]+)\\.js$/);\n    var filename = splitResult && splitResult[1];\n\n    if (!filename) {\n      return [src.replace(\".js\", \".css\")];\n    }\n\n    if (!fileMap) {\n      return [src.replace(\".js\", \".css\")];\n    }\n\n    return fileMap.split(\",\").map(function (mapRule) {\n      var reg = new RegExp(\"\".concat(filename, \"\\\\.js$\"), \"g\");\n      return normalizeUrl(src.replace(reg, \"\".concat(mapRule.replace(/{fileName}/g, filename), \".css\")));\n    });\n  };\n}\n/**\n * @param {TODO} el\n * @param {string} [url]\n */\n\n\nfunction updateCss(el, url) {\n  if (!url) {\n    if (!el.href) {\n      return;\n    } // eslint-disable-next-line\n\n\n    url = el.href.split(\"?\")[0];\n  }\n\n  if (!isUrlRequest(\n  /** @type {string} */\n  url)) {\n    return;\n  }\n\n  if (el.isLoaded === false) {\n    // We seem to be about to replace a css link that hasn't loaded yet.\n    // We're probably changing the same file more than once.\n    return;\n  }\n\n  if (!url || !(url.indexOf(\".css\") > -1)) {\n    return;\n  } // eslint-disable-next-line no-param-reassign\n\n\n  el.visited = true;\n  var newEl = el.cloneNode();\n  newEl.isLoaded = false;\n  newEl.addEventListener(\"load\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.addEventListener(\"error\", function () {\n    if (newEl.isLoaded) {\n      return;\n    }\n\n    newEl.isLoaded = true;\n    el.parentNode.removeChild(el);\n  });\n  newEl.href = \"\".concat(url, \"?\").concat(Date.now());\n\n  if (el.nextSibling) {\n    el.parentNode.insertBefore(newEl, el.nextSibling);\n  } else {\n    el.parentNode.appendChild(newEl);\n  }\n}\n/**\n * @param {string} href\n * @param {TODO} src\n * @returns {TODO}\n */\n\n\nfunction getReloadUrl(href, src) {\n  var ret; // eslint-disable-next-line no-param-reassign\n\n  href = normalizeUrl(href);\n  src.some(\n  /**\n   * @param {string} url\n   */\n  // eslint-disable-next-line array-callback-return\n  function (url) {\n    if (href.indexOf(src) > -1) {\n      ret = url;\n    }\n  });\n  return ret;\n}\n/**\n * @param {string} [src]\n * @returns {boolean}\n */\n\n\nfunction reloadStyle(src) {\n  if (!src) {\n    return false;\n  }\n\n  var elements = document.querySelectorAll(\"link\");\n  var loaded = false;\n  forEach.call(elements, function (el) {\n    if (!el.href) {\n      return;\n    }\n\n    var url = getReloadUrl(el.href, src);\n\n    if (!isUrlRequest(url)) {\n      return;\n    }\n\n    if (el.visited === true) {\n      return;\n    }\n\n    if (url) {\n      updateCss(el, url);\n      loaded = true;\n    }\n  });\n  return loaded;\n}\n\nfunction reloadAll() {\n  var elements = document.querySelectorAll(\"link\");\n  forEach.call(elements, function (el) {\n    if (el.visited === true) {\n      return;\n    }\n\n    updateCss(el);\n  });\n}\n/**\n * @param {string} url\n * @returns {boolean}\n */\n\n\nfunction isUrlRequest(url) {\n  // An URL is not an request if\n  // It is not http or https\n  if (!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(url)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @param {TODO} moduleId\n * @param {TODO} options\n * @returns {TODO}\n */\n\n\nmodule.exports = function (moduleId, options) {\n  if (noDocument) {\n    console.log(\"no window.document found, will not HMR CSS\");\n    return noop;\n  }\n\n  var getScriptSrc = getCurrentScriptUrl(moduleId);\n\n  function update() {\n    var src = getScriptSrc(options.filename);\n    var reloaded = reloadStyle(src);\n\n    if (options.locals) {\n      console.log(\"[HMR] Detected local css modules. Reload all css\");\n      reloadAll();\n      return;\n    }\n\n    if (reloaded) {\n      console.log(\"[HMR] css reload %s\", src.join(\" \"));\n    } else {\n      console.log(\"[HMR] Reload all css\");\n      reloadAll();\n    }\n  }\n\n  return debounce(update, 50);\n};",
    "\"use strict\";\n\n/* eslint-disable */\n\n/**\n * @param {string[]} pathComponents\n * @returns {string}\n */\nfunction normalizeUrl(pathComponents) {\n  return pathComponents.reduce(function (accumulator, item) {\n    switch (item) {\n      case \"..\":\n        accumulator.pop();\n        break;\n\n      case \".\":\n        break;\n\n      default:\n        accumulator.push(item);\n    }\n\n    return accumulator;\n  },\n  /** @type {string[]} */\n  []).join(\"/\");\n}\n/**\n * @param {string} urlString\n * @returns {string}\n */\n\n\nmodule.exports = function (urlString) {\n  urlString = urlString.trim();\n\n  if (/^data:/i.test(urlString)) {\n    return urlString;\n  }\n\n  var protocol = urlString.indexOf(\"//\") !== -1 ? urlString.split(\"//\")[0] + \"//\" : \"\";\n  var components = urlString.replace(new RegExp(protocol, \"i\"), \"\").split(\"/\");\n  var host = components[0].toLowerCase().replace(/\\.$/, \"\");\n  components[0] = \"\";\n  var path = normalizeUrl(components);\n  return protocol + host + path;\n};",
    "// extracted by mini-css-extract-plugin\nexport {};\n    if(module.hot) {\n      // 1651161358077\n      var cssReload = require(\"../node_modules/mini-css-extract-plugin/dist/hmr/hotModuleReplacement.js\")(module.id, {\"locals\":false});\n      module.hot.dispose(cssReload);\n      module.hot.accept(undefined, cssReload);\n    }\n  ",
    "/* Riot v6.1.2, @license MIT */\n/**\n * Convert a string from camel case to dash-case\n * @param   {string} string - probably a component tag name\n * @returns {string} component name normalized\n */\nfunction camelToDashCase(string) {\n  return string.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n}\n/**\n * Convert a string containing dashes to camel case\n * @param   {string} string - input string\n * @returns {string} my-string -> myString\n */\n\nfunction dashToCamelCase(string) {\n  return string.replace(/-(\\w)/g, (_, c) => c.toUpperCase());\n}\n\n/**\n * Get all the element attributes as object\n * @param   {HTMLElement} element - DOM node we want to parse\n * @returns {Object} all the attributes found as a key value pairs\n */\n\nfunction DOMattributesToObject(element) {\n  return Array.from(element.attributes).reduce((acc, attribute) => {\n    acc[dashToCamelCase(attribute.name)] = attribute.value;\n    return acc;\n  }, {});\n}\n/**\n * Move all the child nodes from a source tag to another\n * @param   {HTMLElement} source - source node\n * @param   {HTMLElement} target - target node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n// Ignore this helper because it's needed only for svg tags\n\nfunction moveChildren(source, target) {\n  if (source.firstChild) {\n    target.appendChild(source.firstChild);\n    moveChildren(source, target);\n  }\n}\n/**\n * Remove the child nodes from any DOM node\n * @param   {HTMLElement} node - target node\n * @returns {undefined}\n */\n\nfunction cleanNode(node) {\n  clearChildren(node.childNodes);\n}\n/**\n * Clear multiple children in a node\n * @param   {HTMLElement[]} children - direct children nodes\n * @returns {undefined}\n */\n\nfunction clearChildren(children) {\n  Array.from(children).forEach(removeChild);\n}\n/**\n * Remove a node\n * @param {HTMLElement}node - node to remove\n * @returns {undefined}\n */\n\nconst removeChild = node => node && node.parentNode && node.parentNode.removeChild(node);\n/**\n * Insert before a node\n * @param {HTMLElement} newNode - node to insert\n * @param {HTMLElement} refNode - ref child\n * @returns {undefined}\n */\n\nconst insertBefore = (newNode, refNode) => refNode && refNode.parentNode && refNode.parentNode.insertBefore(newNode, refNode);\n/**\n * Replace a node\n * @param {HTMLElement} newNode - new node to add to the DOM\n * @param {HTMLElement} replaced - node to replace\n * @returns {undefined}\n */\n\nconst replaceChild = (newNode, replaced) => replaced && replaced.parentNode && replaced.parentNode.replaceChild(newNode, replaced);\n\n// Riot.js constants that can be used accross more modules\nconst COMPONENTS_IMPLEMENTATION_MAP$1 = new Map(),\n      DOM_COMPONENT_INSTANCE_PROPERTY$1 = Symbol('riot-component'),\n      PLUGINS_SET$1 = new Set(),\n      IS_DIRECTIVE = 'is',\n      VALUE_ATTRIBUTE = 'value',\n      MOUNT_METHOD_KEY = 'mount',\n      UPDATE_METHOD_KEY = 'update',\n      UNMOUNT_METHOD_KEY = 'unmount',\n      SHOULD_UPDATE_KEY = 'shouldUpdate',\n      ON_BEFORE_MOUNT_KEY = 'onBeforeMount',\n      ON_MOUNTED_KEY = 'onMounted',\n      ON_BEFORE_UPDATE_KEY = 'onBeforeUpdate',\n      ON_UPDATED_KEY = 'onUpdated',\n      ON_BEFORE_UNMOUNT_KEY = 'onBeforeUnmount',\n      ON_UNMOUNTED_KEY = 'onUnmounted',\n      PROPS_KEY = 'props',\n      STATE_KEY = 'state',\n      SLOTS_KEY = 'slots',\n      ROOT_KEY = 'root',\n      IS_PURE_SYMBOL = Symbol('pure'),\n      IS_COMPONENT_UPDATING = Symbol('is_updating'),\n      PARENT_KEY_SYMBOL = Symbol('parent'),\n      ATTRIBUTES_KEY_SYMBOL = Symbol('attributes'),\n      TEMPLATE_KEY_SYMBOL = Symbol('template');\n\nvar globals = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  COMPONENTS_IMPLEMENTATION_MAP: COMPONENTS_IMPLEMENTATION_MAP$1,\n  DOM_COMPONENT_INSTANCE_PROPERTY: DOM_COMPONENT_INSTANCE_PROPERTY$1,\n  PLUGINS_SET: PLUGINS_SET$1,\n  IS_DIRECTIVE: IS_DIRECTIVE,\n  VALUE_ATTRIBUTE: VALUE_ATTRIBUTE,\n  MOUNT_METHOD_KEY: MOUNT_METHOD_KEY,\n  UPDATE_METHOD_KEY: UPDATE_METHOD_KEY,\n  UNMOUNT_METHOD_KEY: UNMOUNT_METHOD_KEY,\n  SHOULD_UPDATE_KEY: SHOULD_UPDATE_KEY,\n  ON_BEFORE_MOUNT_KEY: ON_BEFORE_MOUNT_KEY,\n  ON_MOUNTED_KEY: ON_MOUNTED_KEY,\n  ON_BEFORE_UPDATE_KEY: ON_BEFORE_UPDATE_KEY,\n  ON_UPDATED_KEY: ON_UPDATED_KEY,\n  ON_BEFORE_UNMOUNT_KEY: ON_BEFORE_UNMOUNT_KEY,\n  ON_UNMOUNTED_KEY: ON_UNMOUNTED_KEY,\n  PROPS_KEY: PROPS_KEY,\n  STATE_KEY: STATE_KEY,\n  SLOTS_KEY: SLOTS_KEY,\n  ROOT_KEY: ROOT_KEY,\n  IS_PURE_SYMBOL: IS_PURE_SYMBOL,\n  IS_COMPONENT_UPDATING: IS_COMPONENT_UPDATING,\n  PARENT_KEY_SYMBOL: PARENT_KEY_SYMBOL,\n  ATTRIBUTES_KEY_SYMBOL: ATTRIBUTES_KEY_SYMBOL,\n  TEMPLATE_KEY_SYMBOL: TEMPLATE_KEY_SYMBOL\n});\n\nconst EACH = 0;\nconst IF = 1;\nconst SIMPLE = 2;\nconst TAG = 3;\nconst SLOT = 4;\nvar bindingTypes = {\n  EACH,\n  IF,\n  SIMPLE,\n  TAG,\n  SLOT\n};\n\nconst ATTRIBUTE = 0;\nconst EVENT = 1;\nconst TEXT = 2;\nconst VALUE = 3;\nvar expressionTypes = {\n  ATTRIBUTE,\n  EVENT,\n  TEXT,\n  VALUE\n};\n\nconst HEAD_SYMBOL = Symbol('head');\nconst TAIL_SYMBOL = Symbol('tail');\n\n/**\n * Create the <template> fragments text nodes\n * @return {Object} {{head: Text, tail: Text}}\n */\n\nfunction createHeadTailPlaceholders() {\n  const head = document.createTextNode('');\n  const tail = document.createTextNode('');\n  head[HEAD_SYMBOL] = true;\n  tail[TAIL_SYMBOL] = true;\n  return {\n    head,\n    tail\n  };\n}\n\n/**\n * Create the template meta object in case of <template> fragments\n * @param   {TemplateChunk} componentTemplate - template chunk object\n * @returns {Object} the meta property that will be passed to the mount function of the TemplateChunk\n */\n\nfunction createTemplateMeta(componentTemplate) {\n  const fragment = componentTemplate.dom.cloneNode(true);\n  const {\n    head,\n    tail\n  } = createHeadTailPlaceholders();\n  return {\n    avoidDOMInjection: true,\n    fragment,\n    head,\n    tail,\n    children: [head, ...Array.from(fragment.childNodes), tail]\n  };\n}\n\n/**\n * Helper function to set an immutable property\n * @param   {Object} source - object where the new property will be set\n * @param   {string} key - object key where the new property will be stored\n * @param   {*} value - value of the new property\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} - the original object modified\n */\nfunction defineProperty(source, key, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  /* eslint-disable fp/no-mutating-methods */\n  Object.defineProperty(source, key, Object.assign({\n    value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  /* eslint-enable fp/no-mutating-methods */\n\n  return source;\n}\n/**\n * Define multiple properties on a target object\n * @param   {Object} source - object where the new properties will be set\n * @param   {Object} properties - object containing as key pair the key + value properties\n * @param   {Object} options - set the propery overriding the default options\n * @returns {Object} the original object modified\n */\n\nfunction defineProperties(source, properties, options) {\n  Object.entries(properties).forEach(_ref => {\n    let [key, value] = _ref;\n    defineProperty(source, key, value, options);\n  });\n  return source;\n}\n/**\n * Define default properties if they don't exist on the source object\n * @param   {Object} source - object that will receive the default properties\n * @param   {Object} defaults - object containing additional optional keys\n * @returns {Object} the original object received enhanced\n */\n\nfunction defineDefaults(source, defaults) {\n  Object.entries(defaults).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    if (!source[key]) source[key] = value;\n  });\n  return source;\n}\n\n/**\n * Quick type checking\n * @param   {*} element - anything\n * @param   {string} type - type definition\n * @returns {boolean} true if the type corresponds\n */\nfunction checkType(element, type) {\n  return typeof element === type;\n}\n/**\n * Check if an element is part of an svg\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if we are in an svg context\n */\n\nfunction isSvg(el) {\n  const owner = el.ownerSVGElement;\n  return !!owner || owner === null;\n}\n/**\n * Check if an element is a template tag\n * @param   {HTMLElement}  el - element to check\n * @returns {boolean} true if it's a <template>\n */\n\nfunction isTemplate(el) {\n  return el.tagName.toLowerCase() === 'template';\n}\n/**\n * Check that will be passed if its argument is a function\n * @param   {*} value - value to check\n * @returns {boolean} - true if the value is a function\n */\n\nfunction isFunction(value) {\n  return checkType(value, 'function');\n}\n/**\n * Check if a value is a Boolean\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is a boolean\n */\n\nfunction isBoolean(value) {\n  return checkType(value, 'boolean');\n}\n/**\n * Check if a value is an Object\n * @param   {*}  value - anything\n * @returns {boolean} true only for the value is an object\n */\n\nfunction isObject(value) {\n  return !isNil(value) && value.constructor === Object;\n}\n/**\n * Check if a value is null or undefined\n * @param   {*}  value - anything\n * @returns {boolean} true only for the 'undefined' and 'null' types\n */\n\nfunction isNil(value) {\n  return value === null || value === undefined;\n}\n\n/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n// fork of https://github.com/WebReflection/udomdiff version 1.1.0\n// due to https://github.com/WebReflection/udomdiff/pull/2\n\n/* eslint-disable */\n\n/**\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\n\nvar udomdiff = ((a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ? bStart ? get(b[bStart - 1], -0).nextSibling : get(b[bEnd - bStart], 0) : before;\n\n      while (bStart < bEnd) insertBefore(get(b[bStart++], 1), node);\n    } // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart])) removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    } // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    } // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    } // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      insertBefore(get(b[bStart++], 1), get(a[aStart++], -1).nextSibling);\n      insertBefore(get(b[--bEnd], 1), node); // mark the future index as identical (yeah, it's dirty, but cheap 👍)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n\n      a[aEnd] = b[bEnd];\n    } // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map();\n        let i = bStart;\n\n        while (i < bEnd) map.set(b[i], i++);\n      } // if it's a future node, hence it needs some handling\n\n\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]); // if it's not already processed, look on demand for the next LCS\n\n        if (bStart < index && index < bEnd) {\n          let i = aStart; // counts the amount of nodes that are the same in the future\n\n          let sequence = 1;\n\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === index + sequence) sequence++; // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n\n\n          if (sequence > index - bStart) {\n            const node = get(a[aStart], 0);\n\n            while (bStart < index) insertBefore(get(b[bStart++], 1), node);\n          } // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            replaceChild(get(b[bStart++], 1), get(a[aStart++], -1));\n          }\n        } // otherwise move the source forward, 'cause there's nothing to do\n        else aStart++;\n      } // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else removeChild(get(a[aStart++], -1));\n    }\n  }\n\n  return b;\n});\n\nconst UNMOUNT_SCOPE = Symbol('unmount');\nconst EachBinding = {\n  // dynamic binding properties\n  // childrenMap: null,\n  // node: null,\n  // root: null,\n  // condition: null,\n  // evaluate: null,\n  // template: null,\n  // isTemplateTag: false,\n  nodes: [],\n\n  // getKey: null,\n  // indexName: null,\n  // itemName: null,\n  // afterPlaceholder: null,\n  // placeholder: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const {\n      placeholder,\n      nodes,\n      childrenMap\n    } = this;\n    const collection = scope === UNMOUNT_SCOPE ? null : this.evaluate(scope);\n    const items = collection ? Array.from(collection) : []; // prepare the diffing\n\n    const {\n      newChildrenMap,\n      batches,\n      futureNodes\n    } = createPatch(items, scope, parentScope, this); // patch the DOM only if there are new nodes\n\n    udomdiff(nodes, futureNodes, patch(Array.from(childrenMap.values()), parentScope), placeholder); // trigger the mounts and the updates\n\n    batches.forEach(fn => fn()); // update the children map\n\n    this.childrenMap = newChildrenMap;\n    this.nodes = futureNodes;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.update(UNMOUNT_SCOPE, parentScope);\n    return this;\n  }\n\n};\n/**\n * Patch the DOM while diffing\n * @param   {any[]} redundant - list of all the children (template, nodes, context) added via each\n * @param   {*} parentScope - scope of the parent template\n * @returns {Function} patch function used by domdiff\n */\n\nfunction patch(redundant, parentScope) {\n  return (item, info) => {\n    if (info < 0) {\n      // get the last element added to the childrenMap saved previously\n      const element = redundant[redundant.length - 1];\n\n      if (element) {\n        // get the nodes and the template in stored in the last child of the childrenMap\n        const {\n          template,\n          nodes,\n          context\n        } = element; // remove the last node (notice <template> tags might have more children nodes)\n\n        nodes.pop(); // notice that we pass null as last argument because\n        // the root node and its children will be removed by domdiff\n\n        if (!nodes.length) {\n          // we have cleared all the children nodes and we can unmount this template\n          redundant.pop();\n          template.unmount(context, parentScope, null);\n        }\n      }\n    }\n\n    return item;\n  };\n}\n/**\n * Check whether a template must be filtered from a loop\n * @param   {Function} condition - filter function\n * @param   {Object} context - argument passed to the filter function\n * @returns {boolean} true if this item should be skipped\n */\n\n\nfunction mustFilterItem(condition, context) {\n  return condition ? !condition(context) : false;\n}\n/**\n * Extend the scope of the looped template\n * @param   {Object} scope - current template scope\n * @param   {Object} options - options\n * @param   {string} options.itemName - key to identify the looped item in the new context\n * @param   {string} options.indexName - key to identify the index of the looped item\n * @param   {number} options.index - current index\n * @param   {*} options.item - collection item looped\n * @returns {Object} enhanced scope object\n */\n\n\nfunction extendScope(scope, _ref) {\n  let {\n    itemName,\n    indexName,\n    index,\n    item\n  } = _ref;\n  defineProperty(scope, itemName, item);\n  if (indexName) defineProperty(scope, indexName, index);\n  return scope;\n}\n/**\n * Loop the current template items\n * @param   {Array} items - expression collection value\n * @param   {*} scope - template scope\n * @param   {*} parentScope - scope of the parent template\n * @param   {EachBinding} binding - each binding object instance\n * @returns {Object} data\n * @returns {Map} data.newChildrenMap - a Map containing the new children template structure\n * @returns {Array} data.batches - array containing the template lifecycle functions to trigger\n * @returns {Array} data.futureNodes - array containing the nodes we need to diff\n */\n\n\nfunction createPatch(items, scope, parentScope, binding) {\n  const {\n    condition,\n    template,\n    childrenMap,\n    itemName,\n    getKey,\n    indexName,\n    root,\n    isTemplateTag\n  } = binding;\n  const newChildrenMap = new Map();\n  const batches = [];\n  const futureNodes = [];\n  items.forEach((item, index) => {\n    const context = extendScope(Object.create(scope), {\n      itemName,\n      indexName,\n      index,\n      item\n    });\n    const key = getKey ? getKey(context) : index;\n    const oldItem = childrenMap.get(key);\n    const nodes = [];\n\n    if (mustFilterItem(condition, context)) {\n      return;\n    }\n\n    const mustMount = !oldItem;\n    const componentTemplate = oldItem ? oldItem.template : template.clone();\n    const el = componentTemplate.el || root.cloneNode();\n    const meta = isTemplateTag && mustMount ? createTemplateMeta(componentTemplate) : componentTemplate.meta;\n\n    if (mustMount) {\n      batches.push(() => componentTemplate.mount(el, context, parentScope, meta));\n    } else {\n      batches.push(() => componentTemplate.update(context, parentScope));\n    } // create the collection of nodes to update or to add\n    // in case of template tags we need to add all its children nodes\n\n\n    if (isTemplateTag) {\n      nodes.push(...meta.children);\n    } else {\n      nodes.push(el);\n    } // delete the old item from the children map\n\n\n    childrenMap.delete(key);\n    futureNodes.push(...nodes); // update the children map\n\n    newChildrenMap.set(key, {\n      nodes,\n      template: componentTemplate,\n      context,\n      index\n    });\n  });\n  return {\n    newChildrenMap,\n    batches,\n    futureNodes\n  };\n}\n\nfunction create$6(node, _ref2) {\n  let {\n    evaluate,\n    condition,\n    itemName,\n    indexName,\n    getKey,\n    template\n  } = _ref2;\n  const placeholder = document.createTextNode('');\n  const root = node.cloneNode();\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, EachBinding, {\n    childrenMap: new Map(),\n    node,\n    root,\n    condition,\n    evaluate,\n    isTemplateTag: isTemplate(root),\n    template: template.createDOM(node),\n    getKey,\n    indexName,\n    itemName,\n    placeholder\n  });\n}\n\n/**\n * Binding responsible for the `if` directive\n */\n\nconst IfBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // isTemplateTag: false,\n  // placeholder: null,\n  // template: null,\n  // API methods\n  mount(scope, parentScope) {\n    return this.update(scope, parentScope);\n  },\n\n  update(scope, parentScope) {\n    const value = !!this.evaluate(scope);\n    const mustMount = !this.value && value;\n    const mustUnmount = this.value && !value;\n\n    const mount = () => {\n      const pristine = this.node.cloneNode();\n      insertBefore(pristine, this.placeholder);\n      this.template = this.template.clone();\n      this.template.mount(pristine, scope, parentScope);\n    };\n\n    switch (true) {\n      case mustMount:\n        mount();\n        break;\n\n      case mustUnmount:\n        this.unmount(scope);\n        break;\n\n      default:\n        if (value) this.template.update(scope, parentScope);\n    }\n\n    this.value = value;\n    return this;\n  },\n\n  unmount(scope, parentScope) {\n    this.template.unmount(scope, parentScope, true);\n    return this;\n  }\n\n};\nfunction create$5(node, _ref) {\n  let {\n    evaluate,\n    template\n  } = _ref;\n  const placeholder = document.createTextNode('');\n  insertBefore(placeholder, node);\n  removeChild(node);\n  return Object.assign({}, IfBinding, {\n    node,\n    evaluate,\n    placeholder,\n    template: template.createDOM(node)\n  });\n}\n\n/**\n * Throw an error with a descriptive message\n * @param   { string } message - error message\n * @returns { undefined } hoppla.. at this point the program should stop working\n */\n\nfunction panic(message) {\n  throw new Error(message);\n}\n/**\n * Returns the memoized (cached) function.\n * // borrowed from https://www.30secondsofcode.org/js/s/memoize\n * @param {Function} fn - function to memoize\n * @returns {Function} memoize function\n */\n\nfunction memoize(fn) {\n  const cache = new Map();\n\n  const cached = val => {\n    return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val);\n  };\n\n  cached.cache = cache;\n  return cached;\n}\n/**\n * Evaluate a list of attribute expressions\n * @param   {Array} attributes - attribute expressions generated by the riot compiler\n * @returns {Object} key value pairs with the result of the computation\n */\n\nfunction evaluateAttributeExpressions(attributes) {\n  return attributes.reduce((acc, attribute) => {\n    const {\n      value,\n      type\n    } = attribute;\n\n    switch (true) {\n      // spread attribute\n      case !attribute.name && type === ATTRIBUTE:\n        return Object.assign({}, acc, value);\n      // value attribute\n\n      case type === VALUE:\n        acc.value = attribute.value;\n        break;\n      // normal attributes\n\n      default:\n        acc[dashToCamelCase(attribute.name)] = attribute.value;\n    }\n\n    return acc;\n  }, {});\n}\n\nconst ElementProto = typeof Element === 'undefined' ? {} : Element.prototype;\nconst isNativeHtmlProperty = memoize(name => ElementProto.hasOwnProperty(name)); // eslint-disable-line\n\n/**\n * Add all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} attributes - object containing the attributes names and values\n * @returns {undefined} sorry it's a void function :(\n */\n\nfunction setAllAttributes(node, attributes) {\n  Object.entries(attributes).forEach(_ref => {\n    let [name, value] = _ref;\n    return attributeExpression(node, {\n      name\n    }, value);\n  });\n}\n/**\n * Remove all the attributes provided\n * @param   {HTMLElement} node - target node\n * @param   {Object} newAttributes - object containing all the new attribute names\n * @param   {Object} oldAttributes - object containing all the old attribute names\n * @returns {undefined} sorry it's a void function :(\n */\n\n\nfunction removeAllAttributes(node, newAttributes, oldAttributes) {\n  const newKeys = newAttributes ? Object.keys(newAttributes) : [];\n  Object.keys(oldAttributes).filter(name => !newKeys.includes(name)).forEach(attribute => node.removeAttribute(attribute));\n}\n/**\n * Check whether the attribute value can be rendered\n * @param {*} value - expression value\n * @returns {boolean} true if we can render this attribute value\n */\n\n\nfunction canRenderAttribute(value) {\n  return value === true || ['string', 'number'].includes(typeof value);\n}\n/**\n * Check whether the attribute should be removed\n * @param {*} value - expression value\n * @returns {boolean} boolean - true if the attribute can be removed}\n */\n\n\nfunction shouldRemoveAttribute(value) {\n  return !value && value !== 0;\n}\n/**\n * This methods handles the DOM attributes updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - attribute name\n * @param   {*} value - new expression value\n * @param   {*} oldValue - the old expression cached value\n * @returns {undefined}\n */\n\n\nfunction attributeExpression(node, _ref2, value, oldValue) {\n  let {\n    name\n  } = _ref2;\n\n  // is it a spread operator? {...attributes}\n  if (!name) {\n    if (oldValue) {\n      // remove all the old attributes\n      removeAllAttributes(node, value, oldValue);\n    } // is the value still truthy?\n\n\n    if (value) {\n      setAllAttributes(node, value);\n    }\n\n    return;\n  } // handle boolean attributes\n\n\n  if (!isNativeHtmlProperty(name) && (isBoolean(value) || isObject(value) || isFunction(value))) {\n    node[name] = value;\n  }\n\n  if (shouldRemoveAttribute(value)) {\n    node.removeAttribute(name);\n  } else if (canRenderAttribute(value)) {\n    node.setAttribute(name, normalizeValue(name, value));\n  }\n}\n/**\n * Get the value as string\n * @param   {string} name - attribute name\n * @param   {*} value - user input value\n * @returns {string} input value as string\n */\n\nfunction normalizeValue(name, value) {\n  // be sure that expressions like selected={ true } will be always rendered as selected='selected'\n  return value === true ? name : value;\n}\n\nconst RE_EVENTS_PREFIX = /^on/;\n\nconst getCallbackAndOptions = value => Array.isArray(value) ? value : [value, false]; // see also https://medium.com/@WebReflection/dom-handleevent-a-cross-platform-standard-since-year-2000-5bf17287fd38\n\n\nconst EventListener = {\n  handleEvent(event) {\n    this[event.type](event);\n  }\n\n};\nconst ListenersWeakMap = new WeakMap();\n\nconst createListener = node => {\n  const listener = Object.create(EventListener);\n  ListenersWeakMap.set(node, listener);\n  return listener;\n};\n/**\n * Set a new event listener\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {string} expression.name - event name\n * @param   {*} value - new expression value\n * @returns {value} the callback just received\n */\n\n\nfunction eventExpression(node, _ref, value) {\n  let {\n    name\n  } = _ref;\n  const normalizedEventName = name.replace(RE_EVENTS_PREFIX, '');\n  const eventListener = ListenersWeakMap.get(node) || createListener(node);\n  const [callback, options] = getCallbackAndOptions(value);\n  const handler = eventListener[normalizedEventName];\n  const mustRemoveEvent = handler && !callback;\n  const mustAddEvent = callback && !handler;\n\n  if (mustRemoveEvent) {\n    node.removeEventListener(normalizedEventName, eventListener);\n  }\n\n  if (mustAddEvent) {\n    node.addEventListener(normalizedEventName, eventListener, options);\n  }\n\n  eventListener[normalizedEventName] = callback;\n}\n\n/**\n * Normalize the user value in order to render a empty string in case of falsy values\n * @param   {*} value - user input value\n * @returns {string} hopefully a string\n */\n\nfunction normalizeStringValue(value) {\n  return isNil(value) ? '' : value;\n}\n\n/**\n * Get the the target text node to update or create one from of a comment node\n * @param   {HTMLElement} node - any html element containing childNodes\n * @param   {number} childNodeIndex - index of the text node in the childNodes list\n * @returns {Text} the text node to update\n */\n\nconst getTextNode = (node, childNodeIndex) => {\n  const target = node.childNodes[childNodeIndex];\n\n  if (target.nodeType === Node.COMMENT_NODE) {\n    const textNode = document.createTextNode('');\n    node.replaceChild(textNode, target);\n    return textNode;\n  }\n\n  return target;\n};\n/**\n * This methods handles a simple text expression update\n * @param   {HTMLElement} node - target node\n * @param   {Object} data - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction textExpression(node, data, value) {\n  node.data = normalizeStringValue(value);\n}\n\n/**\n * This methods handles the input fileds value updates\n * @param   {HTMLElement} node - target node\n * @param   {Object} expression - expression object\n * @param   {*} value - new expression value\n * @returns {undefined}\n */\n\nfunction valueExpression(node, expression, value) {\n  node.value = normalizeStringValue(value);\n}\n\nvar expressions = {\n  [ATTRIBUTE]: attributeExpression,\n  [EVENT]: eventExpression,\n  [TEXT]: textExpression,\n  [VALUE]: valueExpression\n};\n\nconst Expression = {\n  // Static props\n  // node: null,\n  // value: null,\n  // API methods\n\n  /**\n   * Mount the expression evaluating its initial value\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  mount(scope) {\n    // hopefully a pure function\n    this.value = this.evaluate(scope); // IO() DOM updates\n\n    apply(this, this.value);\n    return this;\n  },\n\n  /**\n   * Update the expression if its value changed\n   * @param   {*} scope - argument passed to the expression to evaluate its current values\n   * @returns {Expression} self\n   */\n  update(scope) {\n    // pure function\n    const value = this.evaluate(scope);\n\n    if (this.value !== value) {\n      // IO() DOM updates\n      apply(this, value);\n      this.value = value;\n    }\n\n    return this;\n  },\n\n  /**\n   * Expression teardown method\n   * @returns {Expression} self\n   */\n  unmount() {\n    // unmount only the event handling expressions\n    if (this.type === EVENT) apply(this, null);\n    return this;\n  }\n\n};\n/**\n * IO() function to handle the DOM updates\n * @param {Expression} expression - expression object\n * @param {*} value - current expression value\n * @returns {undefined}\n */\n\nfunction apply(expression, value) {\n  return expressions[expression.type](expression.node, expression, value, expression.value);\n}\n\nfunction create$4(node, data) {\n  return Object.assign({}, Expression, data, {\n    node: data.type === TEXT ? getTextNode(node, data.childNodeIndex) : node\n  });\n}\n\n/**\n * Create a flat object having as keys a list of methods that if dispatched will propagate\n * on the whole collection\n * @param   {Array} collection - collection to iterate\n * @param   {Array<string>} methods - methods to execute on each item of the collection\n * @param   {*} context - context returned by the new methods created\n * @returns {Object} a new object to simplify the the nested methods dispatching\n */\nfunction flattenCollectionMethods(collection, methods, context) {\n  return methods.reduce((acc, method) => {\n    return Object.assign({}, acc, {\n      [method]: scope => {\n        return collection.map(item => item[method](scope)) && context;\n      }\n    });\n  }, {});\n}\n\nfunction create$3(node, _ref) {\n  let {\n    expressions\n  } = _ref;\n  return Object.assign({}, flattenCollectionMethods(expressions.map(expression => create$4(node, expression)), ['mount', 'update', 'unmount']));\n}\n\nfunction extendParentScope(attributes, scope, parentScope) {\n  if (!attributes || !attributes.length) return parentScope;\n  const expressions = attributes.map(attr => Object.assign({}, attr, {\n    value: attr.evaluate(scope)\n  }));\n  return Object.assign(Object.create(parentScope || null), evaluateAttributeExpressions(expressions));\n} // this function is only meant to fix an edge case\n// https://github.com/riot/riot/issues/2842\n\n\nconst getRealParent = (scope, parentScope) => scope[PARENT_KEY_SYMBOL] || parentScope;\n\nconst SlotBinding = {\n  // dynamic binding properties\n  // node: null,\n  // name: null,\n  attributes: [],\n\n  // template: null,\n  getTemplateScope(scope, parentScope) {\n    return extendParentScope(this.attributes, scope, parentScope);\n  },\n\n  // API methods\n  mount(scope, parentScope) {\n    const templateData = scope.slots ? scope.slots.find(_ref => {\n      let {\n        id\n      } = _ref;\n      return id === this.name;\n    }) : false;\n    const {\n      parentNode\n    } = this.node;\n    const realParent = getRealParent(scope, parentScope);\n    this.template = templateData && create(templateData.html, templateData.bindings).createDOM(parentNode);\n\n    if (this.template) {\n      cleanNode(this.node);\n      this.template.mount(this.node, this.getTemplateScope(scope, realParent), realParent);\n      this.template.children = Array.from(this.node.childNodes);\n    }\n\n    moveSlotInnerContent(this.node);\n    removeChild(this.node);\n    return this;\n  },\n\n  update(scope, parentScope) {\n    if (this.template) {\n      const realParent = getRealParent(scope, parentScope);\n      this.template.update(this.getTemplateScope(scope, realParent), realParent);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (this.template) {\n      this.template.unmount(this.getTemplateScope(scope, parentScope), null, mustRemoveRoot);\n    }\n\n    return this;\n  }\n\n};\n/**\n * Move the inner content of the slots outside of them\n * @param   {HTMLElement} slot - slot node\n * @returns {undefined} it's a void method ¯\\_(ツ)_/¯\n */\n\nfunction moveSlotInnerContent(slot) {\n  const child = slot && slot.firstChild;\n  if (!child) return;\n  insertBefore(child, slot);\n  moveSlotInnerContent(slot);\n}\n/**\n * Create a single slot binding\n * @param   {HTMLElement} node - slot node\n * @param   {string} name - slot id\n * @param   {AttributeExpressionData[]} attributes - slot attributes\n * @returns {Object} Slot binding object\n */\n\n\nfunction createSlot(node, _ref2) {\n  let {\n    name,\n    attributes\n  } = _ref2;\n  return Object.assign({}, SlotBinding, {\n    attributes,\n    node,\n    name\n  });\n}\n\n/**\n * Create a new tag object if it was registered before, otherwise fallback to the simple\n * template chunk\n * @param   {Function} component - component factory function\n * @param   {Array<Object>} slots - array containing the slots markup\n * @param   {Array} attributes - dynamic attributes that will be received by the tag element\n * @returns {TagImplementation|TemplateChunk} a tag implementation or a template chunk as fallback\n */\n\nfunction getTag(component, slots, attributes) {\n  if (slots === void 0) {\n    slots = [];\n  }\n\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  // if this tag was registered before we will return its implementation\n  if (component) {\n    return component({\n      slots,\n      attributes\n    });\n  } // otherwise we return a template chunk\n\n\n  return create(slotsToMarkup(slots), [...slotBindings(slots), {\n    // the attributes should be registered as binding\n    // if we fallback to a normal template chunk\n    expressions: attributes.map(attr => {\n      return Object.assign({\n        type: ATTRIBUTE\n      }, attr);\n    })\n  }]);\n}\n/**\n * Merge all the slots bindings into a single array\n * @param   {Array<Object>} slots - slots collection\n * @returns {Array<Bindings>} flatten bindings array\n */\n\n\nfunction slotBindings(slots) {\n  return slots.reduce((acc, _ref) => {\n    let {\n      bindings\n    } = _ref;\n    return acc.concat(bindings);\n  }, []);\n}\n/**\n * Merge all the slots together in a single markup string\n * @param   {Array<Object>} slots - slots collection\n * @returns {string} markup of all the slots in a single string\n */\n\n\nfunction slotsToMarkup(slots) {\n  return slots.reduce((acc, slot) => {\n    return acc + slot.html;\n  }, '');\n}\n\nconst TagBinding = {\n  // dynamic binding properties\n  // node: null,\n  // evaluate: null,\n  // name: null,\n  // slots: null,\n  // tag: null,\n  // attributes: null,\n  // getComponent: null,\n  mount(scope) {\n    return this.update(scope);\n  },\n\n  update(scope, parentScope) {\n    const name = this.evaluate(scope); // simple update\n\n    if (name && name === this.name) {\n      this.tag.update(scope);\n    } else {\n      // unmount the old tag if it exists\n      this.unmount(scope, parentScope, true); // mount the new tag\n\n      this.name = name;\n      this.tag = getTag(this.getComponent(name), this.slots, this.attributes);\n      this.tag.mount(this.node, scope);\n    }\n\n    return this;\n  },\n\n  unmount(scope, parentScope, keepRootTag) {\n    if (this.tag) {\n      // keep the root tag\n      this.tag.unmount(keepRootTag);\n    }\n\n    return this;\n  }\n\n};\nfunction create$2(node, _ref2) {\n  let {\n    evaluate,\n    getComponent,\n    slots,\n    attributes\n  } = _ref2;\n  return Object.assign({}, TagBinding, {\n    node,\n    evaluate,\n    slots,\n    attributes,\n    getComponent\n  });\n}\n\nvar bindings = {\n  [IF]: create$5,\n  [SIMPLE]: create$3,\n  [EACH]: create$6,\n  [TAG]: create$2,\n  [SLOT]: createSlot\n};\n\n/**\n * Text expressions in a template tag will get childNodeIndex value normalized\n * depending on the position of the <template> tag offset\n * @param   {Expression[]} expressions - riot expressions array\n * @param   {number} textExpressionsOffset - offset of the <template> tag\n * @returns {Expression[]} expressions containing the text expressions normalized\n */\n\nfunction fixTextExpressionsOffset(expressions, textExpressionsOffset) {\n  return expressions.map(e => e.type === TEXT ? Object.assign({}, e, {\n    childNodeIndex: e.childNodeIndex + textExpressionsOffset\n  }) : e);\n}\n/**\n * Bind a new expression object to a DOM node\n * @param   {HTMLElement} root - DOM node where to bind the expression\n * @param   {TagBindingData} binding - binding data\n * @param   {number|null} templateTagOffset - if it's defined we need to fix the text expressions childNodeIndex offset\n * @returns {Binding} Binding object\n */\n\n\nfunction create$1(root, binding, templateTagOffset) {\n  const {\n    selector,\n    type,\n    redundantAttribute,\n    expressions\n  } = binding; // find the node to apply the bindings\n\n  const node = selector ? root.querySelector(selector) : root; // remove eventually additional attributes created only to select this node\n\n  if (redundantAttribute) node.removeAttribute(redundantAttribute);\n  const bindingExpressions = expressions || []; // init the binding\n\n  return (bindings[type] || bindings[SIMPLE])(node, Object.assign({}, binding, {\n    expressions: templateTagOffset && !selector ? fixTextExpressionsOffset(bindingExpressions, templateTagOffset) : bindingExpressions\n  }));\n}\n\nfunction createHTMLTree(html, root) {\n  const template = isTemplate(root) ? root : document.createElement('template');\n  template.innerHTML = html;\n  return template.content;\n} // for svg nodes we need a bit more work\n\n\nfunction createSVGTree(html, container) {\n  // create the SVGNode\n  const svgNode = container.ownerDocument.importNode(new window.DOMParser().parseFromString(`<svg xmlns=\"http://www.w3.org/2000/svg\">${html}</svg>`, 'application/xml').documentElement, true);\n  return svgNode;\n}\n/**\n * Create the DOM that will be injected\n * @param {Object} root - DOM node to find out the context where the fragment will be created\n * @param   {string} html - DOM to create as string\n * @returns {HTMLDocumentFragment|HTMLElement} a new html fragment\n */\n\n\nfunction createDOMTree(root, html) {\n  if (isSvg(root)) return createSVGTree(html, root);\n  return createHTMLTree(html, root);\n}\n\n/**\n * Inject the DOM tree into a target node\n * @param   {HTMLElement} el - target element\n * @param   {DocumentFragment|SVGElement} dom - dom tree to inject\n * @returns {undefined}\n */\n\nfunction injectDOM(el, dom) {\n  switch (true) {\n    case isSvg(el):\n      moveChildren(dom, el);\n      break;\n\n    case isTemplate(el):\n      el.parentNode.replaceChild(dom, el);\n      break;\n\n    default:\n      el.appendChild(dom);\n  }\n}\n\n/**\n * Create the Template DOM skeleton\n * @param   {HTMLElement} el - root node where the DOM will be injected\n * @param   {string|HTMLElement} html - HTML markup or HTMLElement that will be injected into the root node\n * @returns {?DocumentFragment} fragment that will be injected into the root node\n */\n\nfunction createTemplateDOM(el, html) {\n  return html && (typeof html === 'string' ? createDOMTree(el, html) : html);\n}\n/**\n * Get the offset of the <template> tag\n * @param {HTMLElement} parentNode - template tag parent node\n * @param {HTMLElement} el - the template tag we want to render\n * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n * @returns {number} offset of the <template> tag calculated from its siblings DOM nodes\n */\n\n\nfunction getTemplateTagOffset(parentNode, el, meta) {\n  const siblings = Array.from(parentNode.childNodes);\n  return Math.max(siblings.indexOf(el), siblings.indexOf(meta.head) + 1, 0);\n}\n/**\n * Template Chunk model\n * @type {Object}\n */\n\n\nconst TemplateChunk = Object.freeze({\n  // Static props\n  // bindings: null,\n  // bindingsData: null,\n  // html: null,\n  // isTemplateTag: false,\n  // fragment: null,\n  // children: null,\n  // dom: null,\n  // el: null,\n\n  /**\n   * Create the template DOM structure that will be cloned on each mount\n   * @param   {HTMLElement} el - the root node\n   * @returns {TemplateChunk} self\n   */\n  createDOM(el) {\n    // make sure that the DOM gets created before cloning the template\n    this.dom = this.dom || createTemplateDOM(el, this.html) || document.createDocumentFragment();\n    return this;\n  },\n\n  // API methods\n\n  /**\n   * Attach the template to a DOM node\n   * @param   {HTMLElement} el - target DOM node\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {Object} meta - meta properties needed to handle the <template> tags in loops\n   * @returns {TemplateChunk} self\n   */\n  mount(el, scope, parentScope, meta) {\n    if (meta === void 0) {\n      meta = {};\n    }\n\n    if (!el) throw new Error('Please provide DOM node to mount properly your template');\n    if (this.el) this.unmount(scope); // <template> tags require a bit more work\n    // the template fragment might be already created via meta outside of this call\n\n    const {\n      fragment,\n      children,\n      avoidDOMInjection\n    } = meta; // <template> bindings of course can not have a root element\n    // so we check the parent node to set the query selector bindings\n\n    const {\n      parentNode\n    } = children ? children[0] : el;\n    const isTemplateTag = isTemplate(el);\n    const templateTagOffset = isTemplateTag ? getTemplateTagOffset(parentNode, el, meta) : null; // create the DOM if it wasn't created before\n\n    this.createDOM(el); // create the DOM of this template cloning the original DOM structure stored in this instance\n    // notice that if a documentFragment was passed (via meta) we will use it instead\n\n    const cloneNode = fragment || this.dom.cloneNode(true); // store root node\n    // notice that for template tags the root note will be the parent tag\n\n    this.el = isTemplateTag ? parentNode : el; // create the children array only for the <template> fragments\n\n    this.children = isTemplateTag ? children || Array.from(cloneNode.childNodes) : null; // inject the DOM into the el only if a fragment is available\n\n    if (!avoidDOMInjection && cloneNode) injectDOM(el, cloneNode); // create the bindings\n\n    this.bindings = this.bindingsData.map(binding => create$1(this.el, binding, templateTagOffset));\n    this.bindings.forEach(b => b.mount(scope, parentScope)); // store the template meta properties\n\n    this.meta = meta;\n    return this;\n  },\n\n  /**\n   * Update the template with fresh data\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @returns {TemplateChunk} self\n   */\n  update(scope, parentScope) {\n    this.bindings.forEach(b => b.update(scope, parentScope));\n    return this;\n  },\n\n  /**\n   * Remove the template from the node where it was initially mounted\n   * @param   {*} scope - template data\n   * @param   {*} parentScope - scope of the parent template tag\n   * @param   {boolean|null} mustRemoveRoot - if true remove the root element,\n   * if false or undefined clean the root tag content, if null don't touch the DOM\n   * @returns {TemplateChunk} self\n   */\n  unmount(scope, parentScope, mustRemoveRoot) {\n    if (mustRemoveRoot === void 0) {\n      mustRemoveRoot = false;\n    }\n\n    const el = this.el;\n\n    if (!el) {\n      return this;\n    }\n\n    this.bindings.forEach(b => b.unmount(scope, parentScope, mustRemoveRoot));\n\n    switch (true) {\n      // pure components should handle the DOM unmount updates by themselves\n      // for mustRemoveRoot === null don't touch the DOM\n      case el[IS_PURE_SYMBOL] || mustRemoveRoot === null:\n        break;\n      // if children are declared, clear them\n      // applicable for <template> and <slot/> bindings\n\n      case Array.isArray(this.children):\n        clearChildren(this.children);\n        break;\n      // clean the node children only\n\n      case !mustRemoveRoot:\n        cleanNode(el);\n        break;\n      // remove the root node only if the mustRemoveRoot is truly\n\n      case !!mustRemoveRoot:\n        removeChild(el);\n        break;\n    }\n\n    this.el = null;\n    return this;\n  },\n\n  /**\n   * Clone the template chunk\n   * @returns {TemplateChunk} a clone of this object resetting the this.el property\n   */\n  clone() {\n    return Object.assign({}, this, {\n      meta: {},\n      el: null\n    });\n  }\n\n});\n/**\n * Create a template chunk wiring also the bindings\n * @param   {string|HTMLElement} html - template string\n * @param   {BindingData[]} bindings - bindings collection\n * @returns {TemplateChunk} a new TemplateChunk copy\n */\n\nfunction create(html, bindings) {\n  if (bindings === void 0) {\n    bindings = [];\n  }\n\n  return Object.assign({}, TemplateChunk, {\n    html,\n    bindingsData: bindings\n  });\n}\n\n/**\n * Method used to bind expressions to a DOM node\n * @param   {string|HTMLElement} html - your static template html structure\n * @param   {Array} bindings - list of the expressions to bind to update the markup\n * @returns {TemplateChunk} a new TemplateChunk object having the `update`,`mount`, `unmount` and `clone` methods\n *\n * @example\n *\n * riotDOMBindings\n *  .template(\n *   `<div expr0><!----></div><div><p expr1><!----><section expr2></section></p>`,\n *   [\n *     {\n *       selector: '[expr0]',\n *       redundantAttribute: 'expr0',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.time;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr1]',\n *       redundantAttribute: 'expr1',\n *       expressions: [\n *         {\n *           type: expressionTypes.TEXT,\n *           childNodeIndex: 0,\n *           evaluate(scope) {\n *             return scope.name;\n *           },\n *         },\n *         {\n *           type: 'attribute',\n *           name: 'style',\n *           evaluate(scope) {\n *             return scope.style;\n *           },\n *         },\n *       ],\n *     },\n *     {\n *       selector: '[expr2]',\n *       redundantAttribute: 'expr2',\n *       type: bindingTypes.IF,\n *       evaluate(scope) {\n *         return scope.isVisible;\n *       },\n *       template: riotDOMBindings.template('hello there'),\n *     },\n *   ]\n * )\n */\n\nvar DOMBindings = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  template: create,\n  createBinding: create$1,\n  createExpression: create$4,\n  bindingTypes: bindingTypes,\n  expressionTypes: expressionTypes\n});\n\nfunction noop() {\n  return this;\n}\n/**\n * Autobind the methods of a source object to itself\n * @param   {Object} source - probably a riot tag instance\n * @param   {Array<string>} methods - list of the methods to autobind\n * @returns {Object} the original object received\n */\n\nfunction autobindMethods(source, methods) {\n  methods.forEach(method => {\n    source[method] = source[method].bind(source);\n  });\n  return source;\n}\n/**\n * Call the first argument received only if it's a function otherwise return it as it is\n * @param   {*} source - anything\n * @returns {*} anything\n */\n\nfunction callOrAssign(source) {\n  return isFunction(source) ? source.prototype && source.prototype.constructor ? new source() : source() : source;\n}\n\n/**\n * Converts any DOM node/s to a loopable array\n * @param   { HTMLElement|NodeList } els - single html element or a node list\n * @returns { Array } always a loopable object\n */\nfunction domToArray(els) {\n  // can this object be already looped?\n  if (!Array.isArray(els)) {\n    // is it a node list?\n    if (/^\\[object (HTMLCollection|NodeList|Object)\\]$/.test(Object.prototype.toString.call(els)) && typeof els.length === 'number') return Array.from(els);else // if it's a single node\n      // it will be returned as \"array\" with one single entry\n      return [els];\n  } // this object could be looped out of the box\n\n\n  return els;\n}\n\n/**\n * Simple helper to find DOM nodes returning them as array like loopable object\n * @param   { string|DOMNodeList } selector - either the query or the DOM nodes to arraify\n * @param   { HTMLElement }        ctx      - context defining where the query will search for the DOM nodes\n * @returns { Array } DOM nodes found as array\n */\n\nfunction $(selector, ctx) {\n  return domToArray(typeof selector === 'string' ? (ctx || document).querySelectorAll(selector) : selector);\n}\n\n/**\n * Normalize the return values, in case of a single value we avoid to return an array\n * @param   { Array } values - list of values we want to return\n * @returns { Array|string|boolean } either the whole list of values or the single one found\n * @private\n */\n\nconst normalize = values => values.length === 1 ? values[0] : values;\n/**\n * Parse all the nodes received to get/remove/check their attributes\n * @param   { HTMLElement|NodeList|Array } els    - DOM node/s to parse\n * @param   { string|Array }               name   - name or list of attributes\n * @param   { string }                     method - method that will be used to parse the attributes\n * @returns { Array|string } result of the parsing in a list or a single value\n * @private\n */\n\n\nfunction parseNodes(els, name, method) {\n  const names = typeof name === 'string' ? [name] : name;\n  return normalize(domToArray(els).map(el => {\n    return normalize(names.map(n => el[method](n)));\n  }));\n}\n/**\n * Set any attribute on a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Object }              name  - either the name of the attribute to set\n *                                                 or a list of properties as object key - value\n * @param   { string }                     value - the new value of the attribute (optional)\n * @returns { HTMLElement|NodeList|Array } the original array of elements passed to this function\n *\n * @example\n *\n * import { set } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * set(img, 'width', 100)\n *\n * // or also\n * set(img, {\n *   width: 300,\n *   height: 300\n * })\n *\n */\n\n\nfunction set(els, name, value) {\n  const attrs = typeof name === 'object' ? name : {\n    [name]: value\n  };\n  const props = Object.keys(attrs);\n  domToArray(els).forEach(el => {\n    props.forEach(prop => el.setAttribute(prop, attrs[prop]));\n  });\n  return els;\n}\n/**\n * Get any attribute from a single or a list of DOM nodes\n * @param   { HTMLElement|NodeList|Array } els   - DOM node/s to parse\n * @param   { string|Array }               name  - name or list of attributes to get\n * @returns { Array|string } list of the attributes found\n *\n * @example\n *\n * import { get } from 'bianco.attr'\n *\n * const img = document.createElement('img')\n *\n * get(img, 'width') // => '200'\n *\n * // or also\n * get(img, ['width', 'height']) // => ['200', '300']\n *\n * // or also\n * get([img1, img2], ['width', 'height']) // => [['200', '300'], ['500', '200']]\n */\n\nfunction get(els, name) {\n  return parseNodes(els, name, 'getAttribute');\n}\n\nconst CSS_BY_NAME = new Map();\nconst STYLE_NODE_SELECTOR = 'style[riot]'; // memoized curried function\n\nconst getStyleNode = (style => {\n  return () => {\n    // lazy evaluation:\n    // if this function was already called before\n    // we return its cached result\n    if (style) return style; // create a new style element or use an existing one\n    // and cache it internally\n\n    style = $(STYLE_NODE_SELECTOR)[0] || document.createElement('style');\n    set(style, 'type', 'text/css');\n    /* istanbul ignore next */\n\n    if (!style.parentNode) document.head.appendChild(style);\n    return style;\n  };\n})();\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\n\n\nvar cssManager = {\n  CSS_BY_NAME,\n\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { string } name - if it's passed we will map the css to a tagname\n   * @param { string } css - css string\n   * @returns {Object} self\n   */\n  add(name, css) {\n    if (!CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.set(name, css);\n      this.inject();\n    }\n\n    return this;\n  },\n\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   * @returns {Object} self\n   */\n  inject() {\n    getStyleNode().innerHTML = [...CSS_BY_NAME.values()].join('\\n');\n    return this;\n  },\n\n  /**\n   * Remove a tag style from the DOM\n   * @param {string} name a registered tagname\n   * @returns {Object} self\n   */\n  remove(name) {\n    if (CSS_BY_NAME.has(name)) {\n      CSS_BY_NAME.delete(name);\n      this.inject();\n    }\n\n    return this;\n  }\n\n};\n\n/**\n * Function to curry any javascript method\n * @param   {Function}  fn - the target function we want to curry\n * @param   {...[args]} acc - initial arguments\n * @returns {Function|*} it will return a function until the target function\n *                       will receive all of its arguments\n */\nfunction curry(fn) {\n  for (var _len = arguments.length, acc = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    acc[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    args = [...acc, ...args];\n    return args.length < fn.length ? curry(fn, ...args) : fn(...args);\n  };\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   {HTMLElement} element - DOM node we want to inspect\n * @returns {string} name to identify this dom node in riot\n */\n\nfunction getName(element) {\n  return get(element, IS_DIRECTIVE) || element.tagName.toLowerCase();\n}\n\nconst COMPONENT_CORE_HELPERS = Object.freeze({\n  // component helpers\n  $(selector) {\n    return $(selector, this.root)[0];\n  },\n\n  $$(selector) {\n    return $(selector, this.root);\n  }\n\n});\nconst PURE_COMPONENT_API = Object.freeze({\n  [MOUNT_METHOD_KEY]: noop,\n  [UPDATE_METHOD_KEY]: noop,\n  [UNMOUNT_METHOD_KEY]: noop\n});\nconst COMPONENT_LIFECYCLE_METHODS = Object.freeze({\n  [SHOULD_UPDATE_KEY]: noop,\n  [ON_BEFORE_MOUNT_KEY]: noop,\n  [ON_MOUNTED_KEY]: noop,\n  [ON_BEFORE_UPDATE_KEY]: noop,\n  [ON_UPDATED_KEY]: noop,\n  [ON_BEFORE_UNMOUNT_KEY]: noop,\n  [ON_UNMOUNTED_KEY]: noop\n});\nconst MOCKED_TEMPLATE_INTERFACE = Object.assign({}, PURE_COMPONENT_API, {\n  clone: noop,\n  createDOM: noop\n});\n/**\n * Performance optimization for the recursive components\n * @param  {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {Object} component like interface\n */\n\nconst memoizedCreateComponent = memoize(createComponent);\n/**\n * Evaluate the component properties either from its real attributes or from its initial user properties\n * @param   {HTMLElement} element - component root\n * @param   {Object}  initialProps - initial props\n * @returns {Object} component props key value pairs\n */\n\nfunction evaluateInitialProps(element, initialProps) {\n  if (initialProps === void 0) {\n    initialProps = {};\n  }\n\n  return Object.assign({}, DOMattributesToObject(element), callOrAssign(initialProps));\n}\n/**\n * Bind a DOM node to its component object\n * @param   {HTMLElement} node - html node mounted\n * @param   {Object} component - Riot.js component object\n * @returns {Object} the component object received as second argument\n */\n\n\nconst bindDOMNodeToComponentObject = (node, component) => node[DOM_COMPONENT_INSTANCE_PROPERTY$1] = component;\n/**\n * Wrap the Riot.js core API methods using a mapping function\n * @param   {Function} mapFunction - lifting function\n * @returns {Object} an object having the { mount, update, unmount } functions\n */\n\n\nfunction createCoreAPIMethods(mapFunction) {\n  return [MOUNT_METHOD_KEY, UPDATE_METHOD_KEY, UNMOUNT_METHOD_KEY].reduce((acc, method) => {\n    acc[method] = mapFunction(method);\n    return acc;\n  }, {});\n}\n/**\n * Factory function to create the component templates only once\n * @param   {Function} template - component template creation function\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @returns {TemplateChunk} template chunk object\n */\n\n\nfunction componentTemplateFactory(template, componentWrapper) {\n  const components = createSubcomponents(componentWrapper.exports ? componentWrapper.exports.components : {});\n  return template(create, expressionTypes, bindingTypes, name => {\n    // improve support for recursive components\n    if (name === componentWrapper.name) return memoizedCreateComponent(componentWrapper); // return the registered components\n\n    return components[name] || COMPONENTS_IMPLEMENTATION_MAP$1.get(name);\n  });\n}\n/**\n * Create a pure component\n * @param   {Function} pureFactoryFunction - pure component factory function\n * @param   {Array} options.slots - component slots\n * @param   {Array} options.attributes - component attributes\n * @param   {Array} options.template - template factory function\n * @param   {Array} options.template - template factory function\n * @param   {any} options.props - initial component properties\n * @returns {Object} pure component object\n */\n\n\nfunction createPureComponent(pureFactoryFunction, _ref) {\n  let {\n    slots,\n    attributes,\n    props,\n    css,\n    template\n  } = _ref;\n  if (template) panic('Pure components can not have html');\n  if (css) panic('Pure components do not have css');\n  const component = defineDefaults(pureFactoryFunction({\n    slots,\n    attributes,\n    props\n  }), PURE_COMPONENT_API);\n  return createCoreAPIMethods(method => function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // intercept the mount calls to bind the DOM node to the pure object created\n    // see also https://github.com/riot/riot/issues/2806\n    if (method === MOUNT_METHOD_KEY) {\n      const [element] = args; // mark this node as pure element\n\n      defineProperty(element, IS_PURE_SYMBOL, true);\n      bindDOMNodeToComponentObject(element, component);\n    }\n\n    component[method](...args);\n    return component;\n  });\n}\n/**\n * Create the component interface needed for the @riotjs/dom-bindings tag bindings\n * @param   {RiotComponentWrapper} componentWrapper - riot compiler generated object\n * @param   {string} componentWrapper.css - component css\n * @param   {Function} componentWrapper.template - function that will return the dom-bindings template function\n * @param   {Object} componentWrapper.exports - component interface\n * @param   {string} componentWrapper.name - component name\n * @returns {Object} component like interface\n */\n\n\nfunction createComponent(componentWrapper) {\n  const {\n    css,\n    template,\n    exports,\n    name\n  } = componentWrapper;\n  const templateFn = template ? componentTemplateFactory(template, componentWrapper) : MOCKED_TEMPLATE_INTERFACE;\n  return _ref2 => {\n    let {\n      slots,\n      attributes,\n      props\n    } = _ref2;\n    // pure components rendering will be managed by the end user\n    if (exports && exports[IS_PURE_SYMBOL]) return createPureComponent(exports, {\n      slots,\n      attributes,\n      props,\n      css,\n      template\n    });\n    const componentAPI = callOrAssign(exports) || {};\n    const component = defineComponent({\n      css,\n      template: templateFn,\n      componentAPI,\n      name\n    })({\n      slots,\n      attributes,\n      props\n    }); // notice that for the components create via tag binding\n    // we need to invert the mount (state/parentScope) arguments\n    // the template bindings will only forward the parentScope updates\n    // and never deal with the component state\n\n    return {\n      mount(element, parentScope, state) {\n        return component.mount(element, state, parentScope);\n      },\n\n      update(parentScope, state) {\n        return component.update(state, parentScope);\n      },\n\n      unmount(preserveRoot) {\n        return component.unmount(preserveRoot);\n      }\n\n    };\n  };\n}\n/**\n * Component definition function\n * @param   {Object} implementation - the componen implementation will be generated via compiler\n * @param   {Object} component - the component initial properties\n * @returns {Object} a new component implementation object\n */\n\nfunction defineComponent(_ref3) {\n  let {\n    css,\n    template,\n    componentAPI,\n    name\n  } = _ref3;\n  // add the component css into the DOM\n  if (css && name) cssManager.add(name, css);\n  return curry(enhanceComponentAPI)(defineProperties( // set the component defaults without overriding the original component API\n  defineDefaults(componentAPI, Object.assign({}, COMPONENT_LIFECYCLE_METHODS, {\n    [PROPS_KEY]: {},\n    [STATE_KEY]: {}\n  })), Object.assign({\n    // defined during the component creation\n    [SLOTS_KEY]: null,\n    [ROOT_KEY]: null\n  }, COMPONENT_CORE_HELPERS, {\n    name,\n    css,\n    template\n  })));\n}\n/**\n * Create the bindings to update the component attributes\n * @param   {HTMLElement} node - node where we will bind the expressions\n * @param   {Array} attributes - list of attribute bindings\n * @returns {TemplateChunk} - template bindings object\n */\n\nfunction createAttributeBindings(node, attributes) {\n  if (attributes === void 0) {\n    attributes = [];\n  }\n\n  const expressions = attributes.map(a => create$4(node, a));\n  const binding = {};\n  return Object.assign(binding, Object.assign({\n    expressions\n  }, createCoreAPIMethods(method => scope => {\n    expressions.forEach(e => e[method](scope));\n    return binding;\n  })));\n}\n/**\n * Create the subcomponents that can be included inside a tag in runtime\n * @param   {Object} components - components imported in runtime\n * @returns {Object} all the components transformed into Riot.Component factory functions\n */\n\n\nfunction createSubcomponents(components) {\n  if (components === void 0) {\n    components = {};\n  }\n\n  return Object.entries(callOrAssign(components)).reduce((acc, _ref4) => {\n    let [key, value] = _ref4;\n    acc[camelToDashCase(key)] = createComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Run the component instance through all the plugins set by the user\n * @param   {Object} component - component instance\n * @returns {Object} the component enhanced by the plugins\n */\n\n\nfunction runPlugins(component) {\n  return [...PLUGINS_SET$1].reduce((c, fn) => fn(c) || c, component);\n}\n/**\n * Compute the component current state merging it with its previous state\n * @param   {Object} oldState - previous state object\n * @param   {Object} newState - new state givent to the `update` call\n * @returns {Object} new object state\n */\n\n\nfunction computeState(oldState, newState) {\n  return Object.assign({}, oldState, callOrAssign(newState));\n}\n/**\n * Add eventually the \"is\" attribute to link this DOM node to its css\n * @param {HTMLElement} element - target root node\n * @param {string} name - name of the component mounted\n * @returns {undefined} it's a void function\n */\n\n\nfunction addCssHook(element, name) {\n  if (getName(element) !== name) {\n    set(element, IS_DIRECTIVE, name);\n  }\n}\n/**\n * Component creation factory function that will enhance the user provided API\n * @param   {Object} component - a component implementation previously defined\n * @param   {Array} options.slots - component slots generated via riot compiler\n * @param   {Array} options.attributes - attribute expressions generated via riot compiler\n * @returns {Riot.Component} a riot component instance\n */\n\n\nfunction enhanceComponentAPI(component, _ref5) {\n  let {\n    slots,\n    attributes,\n    props\n  } = _ref5;\n  return autobindMethods(runPlugins(defineProperties(isObject(component) ? Object.create(component) : component, {\n    mount(element, state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      // any element mounted passing through this function can't be a pure component\n      defineProperty(element, IS_PURE_SYMBOL, false);\n      this[PARENT_KEY_SYMBOL] = parentScope;\n      this[ATTRIBUTES_KEY_SYMBOL] = createAttributeBindings(element, attributes).mount(parentScope);\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, evaluateInitialProps(element, props), evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions))));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[TEMPLATE_KEY_SYMBOL] = this.template.createDOM(element).clone(); // link this object to the DOM node\n\n      bindDOMNodeToComponentObject(element, this); // add eventually the 'is' attribute\n\n      component.name && addCssHook(element, component.name); // define the root element\n\n      defineProperty(this, ROOT_KEY, element); // define the slots array\n\n      defineProperty(this, SLOTS_KEY, slots); // before mount lifecycle event\n\n      this[ON_BEFORE_MOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]); // mount the template\n\n      this[TEMPLATE_KEY_SYMBOL].mount(element, this, parentScope);\n      this[ON_MOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    },\n\n    update(state, parentScope) {\n      if (state === void 0) {\n        state = {};\n      }\n\n      if (parentScope) {\n        this[PARENT_KEY_SYMBOL] = parentScope;\n        this[ATTRIBUTES_KEY_SYMBOL].update(parentScope);\n      }\n\n      const newProps = evaluateAttributeExpressions(this[ATTRIBUTES_KEY_SYMBOL].expressions);\n      if (this[SHOULD_UPDATE_KEY](newProps, this[PROPS_KEY]) === false) return;\n      defineProperty(this, PROPS_KEY, Object.freeze(Object.assign({}, this[PROPS_KEY], newProps)));\n      this[STATE_KEY] = computeState(this[STATE_KEY], state);\n      this[ON_BEFORE_UPDATE_KEY](this[PROPS_KEY], this[STATE_KEY]); // avoiding recursive updates\n      // see also https://github.com/riot/riot/issues/2895\n\n      if (!this[IS_COMPONENT_UPDATING]) {\n        this[IS_COMPONENT_UPDATING] = true;\n        this[TEMPLATE_KEY_SYMBOL].update(this, this[PARENT_KEY_SYMBOL]);\n      }\n\n      this[ON_UPDATED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[IS_COMPONENT_UPDATING] = false;\n      return this;\n    },\n\n    unmount(preserveRoot) {\n      this[ON_BEFORE_UNMOUNT_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      this[ATTRIBUTES_KEY_SYMBOL].unmount(); // if the preserveRoot is null the template html will be left untouched\n      // in that case the DOM cleanup will happen differently from a parent node\n\n      this[TEMPLATE_KEY_SYMBOL].unmount(this, this[PARENT_KEY_SYMBOL], preserveRoot === null ? null : !preserveRoot);\n      this[ON_UNMOUNTED_KEY](this[PROPS_KEY], this[STATE_KEY]);\n      return this;\n    }\n\n  })), Object.keys(component).filter(prop => isFunction(component[prop])));\n}\n/**\n * Component initialization function starting from a DOM node\n * @param   {HTMLElement} element - element to upgrade\n * @param   {Object} initialProps - initial component properties\n * @param   {string} componentName - component id\n * @returns {Object} a new component instance bound to a DOM node\n */\n\nfunction mountComponent(element, initialProps, componentName) {\n  const name = componentName || getName(element);\n  if (!COMPONENTS_IMPLEMENTATION_MAP$1.has(name)) panic(`The component named \"${name}\" was never registered`);\n  const component = COMPONENTS_IMPLEMENTATION_MAP$1.get(name)({\n    props: initialProps\n  });\n  return component.mount(element);\n}\n\n/**\n * Similar to compose but performs from left-to-right function composition.<br/>\n * {@link https://30secondsofcode.org/function#composeright see also}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n/**\n * Performs right-to-left function composition.<br/>\n * Use Array.prototype.reduce() to perform right-to-left function composition.<br/>\n * The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.<br/>\n * {@link https://30secondsofcode.org/function#compose original source code}\n * @param   {...[function]} fns) - list of unary function\n * @returns {*} result of the computation\n */\n\nfunction compose() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return fns.reduce((f, g) => function () {\n    return f(g(...arguments));\n  });\n}\n\nconst {\n  DOM_COMPONENT_INSTANCE_PROPERTY,\n  COMPONENTS_IMPLEMENTATION_MAP,\n  PLUGINS_SET\n} = globals;\n/**\n * Riot public api\n */\n\n/**\n * Register a custom tag by name\n * @param   {string} name - component name\n * @param   {Object} implementation - tag implementation\n * @returns {Map} map containing all the components implementations\n */\n\nfunction register(name, _ref) {\n  let {\n    css,\n    template,\n    exports\n  } = _ref;\n  if (COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was already registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.set(name, createComponent({\n    name,\n    css,\n    template,\n    exports\n  }));\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Unregister a riot web component\n * @param   {string} name - component name\n * @returns {Map} map containing all the components implementations\n */\n\nfunction unregister(name) {\n  if (!COMPONENTS_IMPLEMENTATION_MAP.has(name)) panic(`The component \"${name}\" was never registered`);\n  COMPONENTS_IMPLEMENTATION_MAP.delete(name);\n  cssManager.remove(name);\n  return COMPONENTS_IMPLEMENTATION_MAP;\n}\n/**\n * Mounting function that will work only for the components that were globally registered\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {Object} initialProps - the initial component properties\n * @param   {string} name - optional component name\n * @returns {Array} list of riot components\n */\n\nfunction mount(selector, initialProps, name) {\n  return $(selector).map(element => mountComponent(element, initialProps, name));\n}\n/**\n * Sweet unmounting helper function for the DOM node mounted manually by the user\n * @param   {string|HTMLElement} selector - query for the selection or a DOM element\n * @param   {boolean|null} keepRootElement - if true keep the root element\n * @returns {Array} list of nodes unmounted\n */\n\nfunction unmount(selector, keepRootElement) {\n  return $(selector).map(element => {\n    if (element[DOM_COMPONENT_INSTANCE_PROPERTY]) {\n      element[DOM_COMPONENT_INSTANCE_PROPERTY].unmount(keepRootElement);\n    }\n\n    return element;\n  });\n}\n/**\n * Define a riot plugin\n * @param   {Function} plugin - function that will receive all the components created\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction install(plugin) {\n  if (!isFunction(plugin)) panic('Plugins must be of type function');\n  if (PLUGINS_SET.has(plugin)) panic('This plugin was already installed');\n  PLUGINS_SET.add(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Uninstall a riot plugin\n * @param   {Function} plugin - plugin previously installed\n * @returns {Set} the set containing all the plugins installed\n */\n\nfunction uninstall(plugin) {\n  if (!PLUGINS_SET.has(plugin)) panic('This plugin was never installed');\n  PLUGINS_SET.delete(plugin);\n  return PLUGINS_SET;\n}\n/**\n * Helper method to create component without relying on the registered ones\n * @param   {Object} implementation - component implementation\n * @returns {Function} function that will allow you to mount a riot component on a DOM node\n */\n\nfunction component(implementation) {\n  return function (el, props, _temp) {\n    let {\n      slots,\n      attributes,\n      parentScope\n    } = _temp === void 0 ? {} : _temp;\n    return compose(c => c.mount(el, parentScope), c => c({\n      props,\n      slots,\n      attributes\n    }), createComponent)(implementation);\n  };\n}\n/**\n * Lift a riot component Interface into a pure riot object\n * @param   {Function} func - RiotPureComponent factory function\n * @returns {Function} the lifted original function received as argument\n */\n\nfunction pure(func) {\n  if (!isFunction(func)) panic('riot.pure accepts only arguments of type \"function\"');\n  func[IS_PURE_SYMBOL] = true;\n  return func;\n}\n/**\n * no-op function needed to add the proper types to your component via typescript\n * @param {Function|Object} component - component default export\n * @returns {Function|Object} returns exactly what it has received\n */\n\nconst withTypes = component => component;\n/** @type {string} current riot version */\n\nconst version = 'v6.1.2'; // expose some internal stuff that might be used from external tools\n\nconst __ = {\n  cssManager,\n  DOMBindings,\n  createComponent,\n  defineComponent,\n  globals\n};\n\nexport { __, component, install, mount, pure, register, uninstall, unmount, unregister, version, withTypes };\n",
    "var RiotControl = {\r\n  _stores: [],\r\n  addStore: function(store) {\r\n    this._stores.push(store);\r\n  },\r\n  reset: function() {\r\n    this._stores = [];\r\n  }\r\n};\r\n\r\n['on','one','off','trigger'].forEach(function(api){\r\n  RiotControl[api] = function() {\r\n    var args = [].slice.call(arguments);\r\n    this._stores.forEach(function(el){\r\n      el[api].apply(el, args);\r\n    });\r\n  };\r\n});\r\n\r\nif (typeof(module) !== 'undefined') module.exports = RiotControl;\r\n",
    "var map = {\n\t\"./todo/todo.riot\": 695\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 191;",
    "import { register } from 'riot'\n\nconst basename = (path, extension = '') =>\n  path.split('/').reverse()[0].replace(extension, '')\nconst globalComponentsContext = require.context(\n  './components/',\n  true,\n  /[a-zA-Z0-9-]+\\.riot/,\n)\n\nexport default () => {\n  globalComponentsContext.keys().map((path) => {\n    const name = basename(path, '.riot')\n\n    const component = globalComponentsContext(path)\n\n    register(name, component.default || component)\n\n    return {\n      name,\n      component,\n    }\n  })\n}\n",
    "import './style.css'\nimport '@riotjs/hot-reload'\nimport { mount } from 'riot'\nimport registerGlobalComponents from './register-global-components'\nimport './libs/todostore'\n\n// register\nregisterGlobalComponents()\n\n// mount all the global components found in this page\nmount('[data-riot-component]')\n",
    "import observable from '@riotjs/observable'\n\n// TodoStore definition.\n// Flux stores house application logic and state that relate to a specific domain.\n// In this case, a list of todo items.\nfunction TodoStore() {\n  observable(this) // Riot provides our event emitter.\n\n  const self = this\n\n  self.todos = [\n    { title: 'Task 1', done: false },\n    { title: 'Task 2', done: false },\n  ]\n\n  // Our store's event handlers / API.\n  // This is where we would use AJAX calls to interface with the server.\n  // Any number of views can emit actions/events without knowing the specifics of the back-end.\n  // This store can easily be swapped for another, while the view components remain untouched.\n\n  self.on('todo_add', (newTodo) => {\n    self.todos.push(newTodo)\n    self.trigger('todos_changed', self.todos)\n  })\n\n  self.on('todo_remove', () => {\n    self.todos.pop()\n    self.trigger('todos_changed', self.todos)\n  })\n\n  self.on('todo_init', () => {\n    self.trigger('todos_changed', self.todos)\n  })\n  // The store emits change events to any listening views, so that they may react and redraw themselves.\n}\n\nexport default TodoStore\n"
  ],
  "names": [
    "exports",
    "riot",
    "$",
    "_interopDefaultLegacy",
    "e",
    "$__default",
    "cssManager",
    "__",
    "DOM_COMPONENT_INSTANCE_PROPERTY",
    "globals",
    "reload",
    "componentAPI",
    "name",
    "map",
    "el",
    "oldTag",
    "unmount",
    "remove",
    "newTag",
    "component",
    "props",
    "update",
    "state",
    "console",
    "warn",
    "default",
    "Object",
    "defineProperty",
    "value",
    "factory",
    "window",
    "undefined",
    "ALL_CALLBACKS",
    "define",
    "defineProperties",
    "entries",
    "on",
    "callbacks",
    "event",
    "fn",
    "has",
    "get",
    "add",
    "set",
    "Set",
    "off",
    "fns",
    "delete",
    "size",
    "deleteCallback",
    "clear",
    "one",
    "args",
    "apply",
    "trigger",
    "forEach",
    "module",
    "Map",
    "reduce",
    "acc",
    "key",
    "method",
    "enumerable",
    "writable",
    "configurable",
    "disabled",
    "items",
    "text",
    "onBeforeMount",
    "todoStore",
    "this",
    "onMounted",
    "edit",
    "target",
    "preventDefault",
    "input",
    "title",
    "toggle",
    "done",
    "item",
    "length",
    "selector",
    "scope",
    "els",
    "document",
    "querySelectorAll",
    "Array",
    "isArray",
    "test",
    "prototype",
    "toString",
    "call",
    "from",
    "normalizeUrl",
    "srcByModuleId",
    "create",
    "noDocument",
    "noop",
    "updateCss",
    "url",
    "href",
    "split",
    "isUrlRequest",
    "isLoaded",
    "indexOf",
    "visited",
    "newEl",
    "cloneNode",
    "addEventListener",
    "parentNode",
    "removeChild",
    "concat",
    "Date",
    "now",
    "nextSibling",
    "insertBefore",
    "appendChild",
    "reloadAll",
    "elements",
    "moduleId",
    "options",
    "log",
    "timeout",
    "getScriptSrc",
    "src",
    "currentScript",
    "scripts",
    "getElementsByTagName",
    "lastScriptTag",
    "fileMap",
    "splitResult",
    "filename",
    "mapRule",
    "reg",
    "RegExp",
    "replace",
    "getCurrentScriptUrl",
    "reloaded",
    "loaded",
    "ret",
    "some",
    "getReloadUrl",
    "reloadStyle",
    "locals",
    "join",
    "self",
    "arguments",
    "functionCall",
    "clearTimeout",
    "setTimeout",
    "urlString",
    "trim",
    "protocol",
    "components",
    "host",
    "toLowerCase",
    "accumulator",
    "pop",
    "push",
    "cssReload",
    "id",
    "hot",
    "dispose",
    "accept",
    "dashToCamelCase",
    "string",
    "_",
    "c",
    "toUpperCase",
    "moveChildren",
    "source",
    "firstChild",
    "cleanNode",
    "node",
    "clearChildren",
    "childNodes",
    "children",
    "newNode",
    "refNode",
    "COMPONENTS_IMPLEMENTATION_MAP$1",
    "DOM_COMPONENT_INSTANCE_PROPERTY$1",
    "Symbol",
    "PLUGINS_SET$1",
    "IS_DIRECTIVE",
    "MOUNT_METHOD_KEY",
    "UPDATE_METHOD_KEY",
    "UNMOUNT_METHOD_KEY",
    "SHOULD_UPDATE_KEY",
    "ON_BEFORE_MOUNT_KEY",
    "ON_MOUNTED_KEY",
    "ON_BEFORE_UPDATE_KEY",
    "ON_UPDATED_KEY",
    "ON_BEFORE_UNMOUNT_KEY",
    "ON_UNMOUNTED_KEY",
    "PROPS_KEY",
    "STATE_KEY",
    "SLOTS_KEY",
    "ROOT_KEY",
    "IS_PURE_SYMBOL",
    "IS_COMPONENT_UPDATING",
    "PARENT_KEY_SYMBOL",
    "ATTRIBUTES_KEY_SYMBOL",
    "TEMPLATE_KEY_SYMBOL",
    "freeze",
    "__proto__",
    "COMPONENTS_IMPLEMENTATION_MAP",
    "PLUGINS_SET",
    "VALUE_ATTRIBUTE",
    "bindingTypes",
    "EACH",
    "IF",
    "SIMPLE",
    "TAG",
    "SLOT",
    "expressionTypes",
    "ATTRIBUTE",
    "EVENT",
    "TEXT",
    "VALUE",
    "HEAD_SYMBOL",
    "TAIL_SYMBOL",
    "assign",
    "properties",
    "_ref",
    "defineDefaults",
    "defaults",
    "_ref2",
    "checkType",
    "element",
    "type",
    "isSvg",
    "owner",
    "ownerSVGElement",
    "isTemplate",
    "tagName",
    "isFunction",
    "isObject",
    "isNil",
    "constructor",
    "UNMOUNT_SCOPE",
    "EachBinding",
    "nodes",
    "mount",
    "parentScope",
    "placeholder",
    "childrenMap",
    "collection",
    "evaluate",
    "newChildrenMap",
    "batches",
    "futureNodes",
    "binding",
    "condition",
    "template",
    "itemName",
    "getKey",
    "indexName",
    "root",
    "isTemplateTag",
    "index",
    "context",
    "extendScope",
    "oldItem",
    "mustFilterItem",
    "mustMount",
    "componentTemplate",
    "clone",
    "meta",
    "fragment",
    "dom",
    "head",
    "tail",
    "createTextNode",
    "createHeadTailPlaceholders",
    "avoidDOMInjection",
    "createTemplateMeta",
    "createPatch",
    "a",
    "b",
    "before",
    "bLength",
    "aEnd",
    "bEnd",
    "aStart",
    "bStart",
    "i",
    "sequence",
    "replaced",
    "replaceChild",
    "udomdiff",
    "redundant",
    "info",
    "patch",
    "values",
    "IfBinding",
    "mustUnmount",
    "pristine",
    "panic",
    "message",
    "Error",
    "memoize",
    "cache",
    "cached",
    "val",
    "evaluateAttributeExpressions",
    "attributes",
    "attribute",
    "ElementProto",
    "Element",
    "isNativeHtmlProperty",
    "hasOwnProperty",
    "RE_EVENTS_PREFIX",
    "EventListener",
    "handleEvent",
    "ListenersWeakMap",
    "WeakMap",
    "normalizeStringValue",
    "getTextNode",
    "childNodeIndex",
    "nodeType",
    "Node",
    "COMMENT_NODE",
    "textNode",
    "expressions",
    "attributeExpression",
    "oldValue",
    "newAttributes",
    "oldAttributes",
    "newKeys",
    "keys",
    "filter",
    "includes",
    "removeAttribute",
    "removeAllAttributes",
    "setAllAttributes",
    "isBoolean",
    "shouldRemoveAttribute",
    "canRenderAttribute",
    "setAttribute",
    "normalizeValue",
    "normalizedEventName",
    "eventListener",
    "listener",
    "createListener",
    "callback",
    "getCallbackAndOptions",
    "handler",
    "mustAddEvent",
    "removeEventListener",
    "data",
    "expression",
    "Expression",
    "create$4",
    "getRealParent",
    "SlotBinding",
    "getTemplateScope",
    "attr",
    "extendParentScope",
    "templateData",
    "slots",
    "find",
    "realParent",
    "html",
    "bindings",
    "createDOM",
    "moveSlotInnerContent",
    "mustRemoveRoot",
    "slot",
    "child",
    "slotBindings",
    "TagBinding",
    "tag",
    "slotsToMarkup",
    "getTag",
    "getComponent",
    "keepRootTag",
    "fixTextExpressionsOffset",
    "textExpressionsOffset",
    "create$1",
    "templateTagOffset",
    "redundantAttribute",
    "querySelector",
    "bindingExpressions",
    "injectDOM",
    "TemplateChunk",
    "container",
    "ownerDocument",
    "importNode",
    "DOMParser",
    "parseFromString",
    "documentElement",
    "createSVGTree",
    "createElement",
    "innerHTML",
    "content",
    "createHTMLTree",
    "createDOMTree",
    "createTemplateDOM",
    "createDocumentFragment",
    "siblings",
    "Math",
    "max",
    "getTemplateTagOffset",
    "bindingsData",
    "DOMBindings",
    "createBinding",
    "createExpression",
    "callOrAssign",
    "domToArray",
    "ctx",
    "normalize",
    "attrs",
    "prop",
    "CSS_BY_NAME",
    "style",
    "css",
    "inject",
    "curry",
    "_len",
    "_key",
    "_len2",
    "_key2",
    "getName",
    "names",
    "n",
    "parseNodes",
    "COMPONENT_CORE_HELPERS",
    "$$",
    "PURE_COMPONENT_API",
    "COMPONENT_LIFECYCLE_METHODS",
    "MOCKED_TEMPLATE_INTERFACE",
    "memoizedCreateComponent",
    "createComponent",
    "bindDOMNodeToComponentObject",
    "createCoreAPIMethods",
    "mapFunction",
    "componentWrapper",
    "templateFn",
    "_ref4",
    "createSubcomponents",
    "componentTemplateFactory",
    "pureFactoryFunction",
    "createPureComponent",
    "defineComponent",
    "preserveRoot",
    "_ref3",
    "enhanceComponentAPI",
    "computeState",
    "oldState",
    "newState",
    "_ref5",
    "runPlugins",
    "createAttributeBindings",
    "initialProps",
    "DOMattributesToObject",
    "evaluateInitialProps",
    "addCssHook",
    "newProps",
    "bind",
    "register",
    "unregister",
    "componentName",
    "mountComponent",
    "keepRootElement",
    "install",
    "plugin",
    "uninstall",
    "implementation",
    "_temp",
    "f",
    "g",
    "compose",
    "pure",
    "func",
    "withTypes",
    "version",
    "RiotControl",
    "_stores",
    "addStore",
    "store",
    "reset",
    "api",
    "slice",
    "webpackContext",
    "req",
    "webpackContextResolve",
    "__webpack_require__",
    "o",
    "code",
    "resolve",
    "globalComponentsContext",
    "path",
    "extension",
    "reverse",
    "basename",
    "todos",
    "newTodo"
  ],
  "sourceRoot": ""
}
